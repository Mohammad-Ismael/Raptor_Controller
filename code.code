#include "mainwindow.h"

#include <QApplication>

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    return a.exec();
}
#include "mainwindow.h"
#include "./ui_mainwindow.h"
#include "windowsutils.h"
#include <QRegularExpression>
#include <QTableWidgetItem>
#include <QTimer>
#include <QMessageBox>
#include <QDateTime>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
    , m_windowsUtils(new WindowsUtils(this))
    , m_pingTimer(nullptr)
    , m_tracerouteTimer(nullptr)
    , m_scanTimer(nullptr)
    , m_pingCount(0)
    , m_tracerouteHop(0)
    , m_currentScanPort(0)
    , m_scanEndPort(0)
    , m_openPortsFound(0)
{
    ui->setupUi(this);

    // Set window properties
    setWindowTitle("Raptor PC Controller");
    setMinimumSize(1000, 700);

    setupConnections();

    // Set initial active button (General)
    on_generalButton_clicked();
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::setupConnections()
{
    // Note: Most connections are auto-connected via Qt's naming convention
}

void MainWindow::resetAllButtons()
{
    // Reset all buttons to default style
    QString defaultStyle =
        "QPushButton {"
        "    background-color: transparent;"
        "    color: white;"
        "    border: none;"
        "    padding: 15px 20px;"
        "    text-align: left;"
        "    border-bottom: 1px solid #34495e;"
        "}"
        "QPushButton:hover {"
        "    background-color: #34495e;"
        "}"
        "QPushButton:pressed {"
        "    background-color: #1abc9c;"
        "}";

    ui->generalButton->setStyleSheet(defaultStyle);
    ui->wifiButton->setStyleSheet(defaultStyle);
    ui->appsButton->setStyleSheet(defaultStyle);
    ui->cleanerButton->setStyleSheet(defaultStyle);
    ui->networkButton->setStyleSheet(defaultStyle);
    ui->hardwareButton->setStyleSheet(defaultStyle);
    ui->optionsButton->setStyleSheet(defaultStyle);
}

void MainWindow::setActiveButton(QPushButton *activeButton)
{
    resetAllButtons();

    // Set active button style with green background
    QString activeStyle =
        "QPushButton {"
        "    background-color: #1abc9c;"
        "    color: white;"
        "    border: none;"
        "    padding: 15px 20px;"
        "    text-align: left;"
        "    border-bottom: 1px solid #34495e;"
        "}"
        "QPushButton:hover {"
        "    background-color: #16a085;"
        "}";

    activeButton->setStyleSheet(activeStyle);
}

void MainWindow::updateContent(const QString &title)
{
    ui->titleLabel->setText(title);
}

void MainWindow::showCleanerPage()
{
    ui->contentStackedWidget->setCurrentWidget(ui->cleanerPage);
}

// Main navigation slots
void MainWindow::on_generalButton_clicked()
{
    setActiveButton(ui->generalButton);
    updateContent("General Settings");
    ui->contentStackedWidget->setCurrentWidget(ui->generalPage);

    // Populate startup programs table
    if (ui->startupTable->rowCount() == 0)
    {
        QStringList startupPrograms = {
            "Microsoft OneDrive", "Spotify", "Adobe Creative Cloud",
            "Discord", "Steam Client", "NVIDIA Control Panel",
            "Realtek Audio", "Windows Security", "Google Update"};

        QStringList impacts = {"Low", "Medium", "High", "Low", "Medium", "Low", "Low", "Low", "Low"};
        QStringList types = {"Registry", "Startup Folder", "Service", "Registry", "Registry", "Service", "Service", "Service", "Scheduled Task"};

        for (int i = 0; i < startupPrograms.size(); ++i)
        {
            int row = ui->startupTable->rowCount();
            ui->startupTable->insertRow(row);

            ui->startupTable->setItem(row, 0, new QTableWidgetItem(startupPrograms[i]));

            QTableWidgetItem *statusItem = new QTableWidgetItem("Enabled");
            statusItem->setForeground(QBrush(QColor("#2ecc71")));
            ui->startupTable->setItem(row, 1, statusItem);

            ui->startupTable->setItem(row, 2, new QTableWidgetItem(impacts[i]));
            ui->startupTable->setItem(row, 3, new QTableWidgetItem(types[i]));
        }
        ui->startupTable->resizeColumnsToContents();
    }
}

void MainWindow::on_wifiButton_clicked()
{
    setActiveButton(ui->wifiButton);
    updateContent("WiFi Management");
    ui->contentStackedWidget->setCurrentWidget(ui->wifiPage);
}

void MainWindow::on_appsButton_clicked()
{
    setActiveButton(ui->appsButton);
    updateContent("Favorite Apps");
    ui->contentStackedWidget->setCurrentWidget(ui->appsPage);

    // Populate apps on first load
    if (ui->appsGridLayout->count() == 0)
    {
        on_refreshAppsButton_clicked();
    }
}

void MainWindow::on_cleanerButton_clicked()
{
    setActiveButton(ui->cleanerButton);
    updateContent("System Cleaner");
    showCleanerPage();
}

void MainWindow::on_optionsButton_clicked()
{
    setActiveButton(ui->optionsButton);
    updateContent("Options & Settings");
    ui->contentStackedWidget->setCurrentWidget(ui->optionsPage);
}

void MainWindow::on_scanQuickButton_clicked()
{
    ui->scanQuickButton->setEnabled(false);
    ui->scanQuickButton->setText("Scanning...");
    ui->quickCleanProgressBar->setValue(0);
    
    // Simple synchronous scan for now
    QVector<CleanerItem> scannedItems = m_windowsUtils->scanJunkFiles();
    
    qint64 totalSize = 0;
    QStringList results;
    results << "Scanning for junk files...\n";
    
    for (int i = 0; i < scannedItems.size(); ++i) {
        const CleanerItem &item = scannedItems[i];
        if (item.isSafe) {
            totalSize += item.size;
            results << QString("‚Ä¢ %1: %2").arg(item.name).arg(formatFileSize(item.size));
        }
    }
    
    results << QString("\nTotal: %1").arg(formatFileSize(totalSize));
    
    ui->quickCleanResults->setPlainText(results.join("\n"));
    ui->spaceSavedLabel->setText(QString("Total space to be freed: %1").arg(formatFileSize(totalSize)));
    ui->cleanQuickButton->setEnabled(true);
    ui->quickCleanProgressBar->setValue(100);
    ui->scanQuickButton->setEnabled(true);
    ui->scanQuickButton->setText("Scan Now");
}

void MainWindow::on_cleanQuickButton_clicked()
{
    ui->cleanQuickButton->setEnabled(false);
    ui->cleanQuickButton->setText("Cleaning...");
    
    // Simple synchronous clean for now
    QVector<CleanerItem> allSafeItems = m_windowsUtils->scanJunkFiles();
    qint64 freedSpace = m_windowsUtils->cleanJunkFiles(allSafeItems);
    
    ui->quickCleanResults->append(QString("\n\nCleaning completed successfully! Freed %1").arg(formatFileSize(freedSpace)));
    ui->cleanQuickButton->setEnabled(false);
    ui->cleanQuickButton->setText("Clean All");
    ui->spaceSavedLabel->setText(QString("Total space freed: %1").arg(formatFileSize(freedSpace)));
}

void MainWindow::on_scanSystemButton_clicked()
{
    ui->scanSystemButton->setEnabled(false);
    ui->scanSystemButton->setText("Scanning...");
    
    // Simple synchronous scan
    QVector<CleanerItem> scannedItems = m_windowsUtils->scanJunkFiles();
    m_currentCleanerItems = scannedItems;
    
    updateSystemCleanerList();
    ui->scanSystemButton->setEnabled(true);
    ui->scanSystemButton->setText("Scan Selected");
    ui->cleanSystemButton->setEnabled(true);
}

void MainWindow::updateSystemCleanerList()
{
    ui->systemCleanerList->clear();
    
    qint64 totalSize = 0;
    
    for (int i = 0; i < m_currentCleanerItems.size(); ++i) {
        const CleanerItem &item = m_currentCleanerItems[i];
        QString displayText = QString("‚úÖ %1 (%2)").arg(item.name).arg(formatFileSize(item.size));
        QListWidgetItem *listItem = new QListWidgetItem(displayText);
        
        // Store the original item data using QVariant
        QVariant itemData;
        itemData.setValue(item);
        listItem->setData(Qt::UserRole, itemData);
        
        // Set selection state
        listItem->setSelected(item.isSelected);
        
        ui->systemCleanerList->addItem(listItem);
        totalSize += item.size;
    }
    
    // Update total size display
    ui->spaceSavedLabel->setText(QString("Total space to be freed: %1").arg(formatFileSize(totalSize)));
}

QString MainWindow::formatFileSize(qint64 bytes)
{
    const qint64 KB = 1024;
    const qint64 MB = KB * 1024;
    const qint64 GB = MB * 1024;
    
    if (bytes >= GB) {
        return QString("%1 GB").arg(QString::number(bytes / (double)GB, 'f', 1));
    } else if (bytes >= MB) {
        return QString("%1 MB").arg(QString::number(bytes / (double)MB, 'f', 1));
    } else if (bytes >= KB) {
        return QString("%1 KB").arg(QString::number(bytes / (double)KB, 'f', 1));
    } else {
        return QString("%1 bytes").arg(bytes);
    }
}


void MainWindow::on_cleanSystemButton_clicked()
{
    // Get selected items
    QVector<CleanerItem> itemsToClean;
    for (int i = 0; i < ui->systemCleanerList->count(); ++i) {
        QListWidgetItem *listItem = ui->systemCleanerList->item(i);
        if (listItem->isSelected()) {
            QVariant itemData = listItem->data(Qt::UserRole);
            CleanerItem item = itemData.value<CleanerItem>();
            itemsToClean.append(item);
        }
    }
    
    if (itemsToClean.isEmpty()) {
        QMessageBox::information(this, "No Selection", "Please select items to clean.");
        return;
    }
    
    // Confirm cleaning
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(this, "Confirm Clean", 
                                 "Are you sure you want to clean the selected items?\nThis action cannot be undone.",
                                 QMessageBox::Yes | QMessageBox::No);
    
    if (reply != QMessageBox::Yes) {
        return;
    }
    
    ui->cleanSystemButton->setEnabled(false);
    ui->cleanSystemButton->setText("Cleaning...");
    
    // Simple synchronous clean
    qint64 freedSpace = m_windowsUtils->cleanJunkFiles(itemsToClean);
    
    ui->cleanSystemButton->setEnabled(false);
    ui->cleanSystemButton->setText("Clean Selected");
    ui->spaceSavedLabel->setText(QString("Total space freed: %1").arg(formatFileSize(freedSpace)));
    
    // Rescan to show updated sizes
    on_scanSystemButton_clicked();
    
    QMessageBox::information(this, "Clean Completed", 
                           QString("Successfully cleaned %1 of disk space.").arg(formatFileSize(freedSpace)));
}

void MainWindow::on_selectAllSystemButton_clicked()
{
    for (int i = 0; i < ui->systemCleanerList->count(); ++i) {
        ui->systemCleanerList->item(i)->setSelected(true);
    }
}


void MainWindow::on_scanBrowsersButton_clicked()
{
    ui->cleanBrowsersButton->setEnabled(true);
}

void MainWindow::on_cleanBrowsersButton_clicked()
{
    ui->cleanBrowsersButton->setEnabled(false);
}

// Software Uninstaller slots
void MainWindow::on_refreshSoftwareButton_clicked()
{
    populateSoftwareTable();
}

void MainWindow::on_searchSoftwareInput_textChanged(const QString &searchText)
{
    // Simple search filter
    if (searchText.isEmpty())
    {
        // Show all items
        for (int i = 0; i < ui->softwareTable->rowCount(); ++i)
        {
            ui->softwareTable->setRowHidden(i, false);
        }
    }
    else
    {
        // Hide non-matching items
        for (int i = 0; i < ui->softwareTable->rowCount(); ++i)
        {
            QTableWidgetItem *item = ui->softwareTable->item(i, 0); // Name column
            bool match = item && item->text().contains(searchText, Qt::CaseInsensitive);
            ui->softwareTable->setRowHidden(i, !match);
        }
    }
}

void MainWindow::on_softwareTable_itemSelectionChanged()
{
    QList<QTableWidgetItem *> selectedItems = ui->softwareTable->selectedItems();
    bool hasSelection = !selectedItems.isEmpty();

    ui->uninstallSoftwareButton->setEnabled(hasSelection);
    ui->forceUninstallButton->setEnabled(hasSelection);

    if (hasSelection)
    {
        int row = ui->softwareTable->currentRow();
        QString name = ui->softwareTable->item(row, 0)->text();
        QString version = ui->softwareTable->item(row, 1)->text();
        QString size = ui->softwareTable->item(row, 2)->text();

        ui->selectedSoftwareInfo->setText(
            QString("Selected: %1 %2 (%3)").arg(name).arg(version).arg(size));
    }
    else
    {
        ui->selectedSoftwareInfo->setText("No software selected");
    }
}

void MainWindow::on_uninstallSoftwareButton_clicked()
{
    // Placeholder for uninstall functionality
    int row = ui->softwareTable->currentRow();
    if (row >= 0)
    {
        QString softwareName = ui->softwareTable->item(row, 0)->text();
        ui->selectedSoftwareInfo->setText(
            QString("Would uninstall: %1 (normal mode)").arg(softwareName));
    }
}

void MainWindow::on_forceUninstallButton_clicked()
{
    // Placeholder for force uninstall functionality
    int row = ui->softwareTable->currentRow();
    if (row >= 0)
    {
        QString softwareName = ui->softwareTable->item(row, 0)->text();
        ui->selectedSoftwareInfo->setText(
            QString("Would force uninstall: %1").arg(softwareName));
    }
}

void MainWindow::populateSoftwareTable()
{
    // Clear existing items
    ui->softwareTable->setRowCount(0);

    // Add sample data - in real implementation, this would query the system
    QStringList sampleSoftware = {
        "Google Chrome", "Mozilla Firefox", "Microsoft Edge", "Visual Studio Code",
        "Adobe Reader", "VLC Media Player", "7-Zip", "WinRAR", "Spotify", "Discord"};

    QStringList versions = {
        "96.0.4664.110", "95.0.2", "96.0.1054.62", "1.63.0",
        "2021.011.20039", "3.0.16", "21.07", "6.02", "1.1.68.610", "1.0.9003"};

    QStringList sizes = {
        "350 MB", "280 MB", "320 MB", "450 MB",
        "650 MB", "85 MB", "2.5 MB", "3.1 MB", "180 MB", "140 MB"};

    QStringList dates = {
        "2023-11-15", "2023-11-10", "2023-11-20", "2023-11-05",
        "2023-10-28", "2023-11-12", "2023-09-15", "2023-10-20", "2023-11-18", "2023-11-22"};

    for (int i = 0; i < sampleSoftware.size(); ++i)
    {
        int row = ui->softwareTable->rowCount();
        ui->softwareTable->insertRow(row);

        ui->softwareTable->setItem(row, 0, new QTableWidgetItem(sampleSoftware[i]));
        ui->softwareTable->setItem(row, 1, new QTableWidgetItem(versions[i]));
        ui->softwareTable->setItem(row, 2, new QTableWidgetItem(sizes[i]));
        ui->softwareTable->setItem(row, 3, new QTableWidgetItem(dates[i]));
    }

    // Resize columns to content
    ui->softwareTable->resizeColumnsToContents();
}

// Apps page slots
void MainWindow::on_addAppButton_clicked()
{
    // Placeholder for adding app functionality
    ui->appsLabel->setText("Add App dialog would open here to browse for applications");
}

void MainWindow::on_refreshAppsButton_clicked()
{
    // Clear existing apps
    QLayoutItem *item;
    while ((item = ui->appsGridLayout->takeAt(0)) != nullptr)
    {
        delete item->widget();
        delete item;
    }

    // Sample favorite apps with emojis
    QVector<QPair<QString, QString>> apps = {
        {"üåê Chrome", "Web Browser"},
        {"üìù VS Code", "Code Editor"},
        {"üéµ Spotify", "Music Player"},
        {"üí¨ Discord", "Chat App"},
        {"üñºÔ∏è Photoshop", "Image Editor"},
        {"üìä Excel", "Spreadsheet"},
        {"üéÆ Steam", "Game Platform"},
        {"üìß Outlook", "Email Client"},
        {"üìÅ Explorer", "File Manager"},
        {"üé• VLC", "Media Player"},
        {"üìö Adobe Reader", "PDF Viewer"},
        {"‚öôÔ∏è Settings", "System Settings"}};

    int row = 0;
    int col = 0;
    const int maxCols = 4;

    for (const auto &app : apps)
    {
        QPushButton *appButton = new QPushButton();
        appButton->setFixedSize(80, 90);
        appButton->setStyleSheet(
            "QPushButton {"
            "    background-color: white;"
            "    border: 2px solid #ecf0f1;"
            "    border-radius: 10px;"
            "    padding: 5px;"
            "}"
            "QPushButton:hover {"
            "    border-color: #1abc9c;"
            "    background-color: #f1f8f6;"
            "}"
            "QPushButton:pressed {"
            "    background-color: #1abc9c;"
            "    color: white;"
            "}");

        QVBoxLayout *buttonLayout = new QVBoxLayout(appButton);
        buttonLayout->setSpacing(5);
        buttonLayout->setContentsMargins(5, 5, 5, 5);

        QLabel *iconLabel = new QLabel(app.first.split(' ')[0]); // Get emoji part
        iconLabel->setAlignment(Qt::AlignCenter);
        iconLabel->setStyleSheet("font-size: 24px; background: transparent;");

        QLabel *nameLabel = new QLabel(app.first.split(' ')[1]); // Get name part
        nameLabel->setAlignment(Qt::AlignCenter);
        nameLabel->setStyleSheet(
            "font-size: 9px;"
            "color: #2c3e50;"
            "background: transparent;"
            "font-weight: bold;");

        QLabel *descLabel = new QLabel(app.second);
        descLabel->setAlignment(Qt::AlignCenter);
        descLabel->setStyleSheet(
            "font-size: 7px;"
            "color: #7f8c8d;"
            "background: transparent;");

        buttonLayout->addWidget(iconLabel);
        buttonLayout->addWidget(nameLabel);
        buttonLayout->addWidget(descLabel);

        // Connect button click
        connect(appButton, &QPushButton::clicked, this, [this, app]()
                {
            ui->selectedAppName->setText(app.first);
            ui->selectedAppPath->setText(app.second);
            ui->selectedAppIcon->setText(app.first.split(' ')[0]);
            ui->launchAppButton->setEnabled(true);
            ui->removeAppButton->setEnabled(true); });

        ui->appsGridLayout->addWidget(appButton, row, col);

        col++;
        if (col >= maxCols)
        {
            col = 0;
            row++;
        }
    }

    // Add stretch to push items to top
    ui->appsGridLayout->setRowStretch(row + 1, 1);
    ui->appsGridLayout->setColumnStretch(maxCols, 1);
}

void MainWindow::on_launchAppButton_clicked()
{
    QString appName = ui->selectedAppName->text();
    if (appName != "No app selected")
    {
        ui->appsLabel->setText(QString("Launching: %1").arg(appName));
        // In real implementation, this would launch the actual application
    }
}

void MainWindow::on_removeAppButton_clicked()
{
    QString appName = ui->selectedAppName->text();
    if (appName != "No app selected")
    {
        ui->appsLabel->setText(QString("Removed from favorites: %1").arg(appName));
        ui->selectedAppName->setText("No app selected");
        ui->selectedAppPath->setText("Select an app to view details");
        ui->selectedAppIcon->setText("üöÄ");
        ui->launchAppButton->setEnabled(false);
        ui->removeAppButton->setEnabled(false);
    }
}

void MainWindow::on_searchAppsInput_textChanged(const QString &searchText)
{
    // Simple search functionality
    for (int i = 0; i < ui->appsGridLayout->count(); ++i)
    {
        QWidget *widget = ui->appsGridLayout->itemAt(i)->widget();
        if (widget)
        {
            QPushButton *appButton = qobject_cast<QPushButton *>(widget);
            if (appButton)
            {
                // Get the app name from the button's layout
                QVBoxLayout *layout = qobject_cast<QVBoxLayout *>(appButton->layout());
                if (layout && layout->itemAt(1))
                {
                    QLabel *nameLabel = qobject_cast<QLabel *>(layout->itemAt(1)->widget());
                    if (nameLabel)
                    {
                        bool match = searchText.isEmpty() ||
                                     nameLabel->text().contains(searchText, Qt::CaseInsensitive);
                        appButton->setVisible(match);
                    }
                }
            }
        }
    }
}

// General tab slots
void MainWindow::on_refreshSystemInfoButton_clicked()
{
    // Simulate refreshing system info
    ui->cpuUsageProgress->setValue(rand() % 100);
    ui->ramUsageProgress->setValue(rand() % 100);
    ui->diskUsageProgress->setValue(rand() % 100);

    ui->cpuUsageValue->setText(QString("%1%").arg(ui->cpuUsageProgress->value()));
    ui->ramUsageValue->setText(QString("%1%").arg(ui->ramUsageProgress->value()));
    ui->diskUsageValue->setText(QString("%1%").arg(ui->diskUsageProgress->value()));
}

void MainWindow::on_generateReportButton_clicked()
{
    // Placeholder for report generation
    ui->systemInfoLabel->setText("System report generated successfully! Check your Documents folder.");
}

void MainWindow::on_disableStartupButton_clicked()
{
    // Placeholder for disabling startup program
    int row = ui->startupTable->currentRow();
    if (row >= 0)
    {
        QTableWidgetItem *statusItem = ui->startupTable->item(row, 1);
        if (statusItem && statusItem->text() == "Enabled")
        {
            statusItem->setText("Disabled");
            statusItem->setForeground(QBrush(QColor("#e74c3c")));
        }
    }
}

void MainWindow::on_enableStartupButton_clicked()
{
    // Placeholder for enabling startup program
    int row = ui->startupTable->currentRow();
    if (row >= 0)
    {
        QTableWidgetItem *statusItem = ui->startupTable->item(row, 1);
        if (statusItem && statusItem->text() == "Disabled")
        {
            statusItem->setText("Enabled");
            statusItem->setForeground(QBrush(QColor("#2ecc71")));
        }
    }
}

void MainWindow::on_startupTable_itemSelectionChanged()
{
    QList<QTableWidgetItem *> selectedItems = ui->startupTable->selectedItems();
    bool hasSelection = !selectedItems.isEmpty();

    if (hasSelection)
    {
        int row = ui->startupTable->currentRow();
        QTableWidgetItem *statusItem = ui->startupTable->item(row, 1);
        bool isEnabled = statusItem && statusItem->text() == "Enabled";

        ui->disableStartupButton->setEnabled(isEnabled);
        ui->enableStartupButton->setEnabled(!isEnabled);
    }
    else
    {
        ui->disableStartupButton->setEnabled(false);
        ui->enableStartupButton->setEnabled(false);
    }
}

// WiFi Management slots
void MainWindow::on_scanNetworksButton_clicked()
{
    ui->diagnosticsOutput->setPlainText("Scanning for available WiFi networks...\n\nFound 8 networks:");
    ui->networksTable->setRowCount(0);

    // Sample network data
    QStringList networks = {"HomeWiFi_5G", "Office_Network", "Guest_WiFi", "TP-Link_2.4G",
                            "NETGEAR_68", "XfinityWifi", "AndroidAP", "Starbucks_Free"};
    QStringList signalStrengths = {"Excellent", "Good", "Fair", "Good", "Excellent", "Weak", "Fair", "Weak"};
    QStringList security = {"WPA2", "WPA3", "WPA2", "WPA2", "WPA3", "Open", "WPA2", "Open"};
    QStringList bands = {"5 GHz", "5 GHz", "2.4 GHz", "2.4 GHz", "5 GHz", "2.4 GHz", "2.4 GHz", "2.4 GHz"};
    QStringList channels = {"36", "149", "6", "11", "44", "1", "3", "9"};

    for (int i = 0; i < networks.size(); ++i)
    {
        int row = ui->networksTable->rowCount();
        ui->networksTable->insertRow(row);

        ui->networksTable->setItem(row, 0, new QTableWidgetItem(networks[i]));
        ui->networksTable->setItem(row, 1, new QTableWidgetItem(signalStrengths[i]));
        ui->networksTable->setItem(row, 2, new QTableWidgetItem(security[i]));
        ui->networksTable->setItem(row, 3, new QTableWidgetItem(bands[i]));
        ui->networksTable->setItem(row, 4, new QTableWidgetItem(channels[i]));
    }

    ui->networksTable->resizeColumnsToContents();
    ui->wifiStatusLabel->setText("WiFi: Scanning Complete");
}

void MainWindow::on_refreshNetworksButton_clicked()
{
    on_scanNetworksButton_clicked();
}

void MainWindow::on_connectNetworkButton_clicked()
{
    int row = ui->networksTable->currentRow();
    if (row >= 0)
    {
        QString networkName = ui->networksTable->item(row, 0)->text();
        ui->selectedNetworkInfo->setText(QString("Connecting to: %1").arg(networkName));
        ui->wifiStatusLabel->setText(QString("WiFi: Connecting to %1").arg(networkName));
    }
}

void MainWindow::on_disconnectNetworkButton_clicked()
{
    ui->selectedNetworkInfo->setText("Disconnected from current network");
    ui->wifiStatusLabel->setText("WiFi: Disconnected");
}

void MainWindow::on_networksTable_itemSelectionChanged()
{
    QList<QTableWidgetItem *> selectedItems = ui->networksTable->selectedItems();
    bool hasSelection = !selectedItems.isEmpty();
    ui->connectNetworkButton->setEnabled(hasSelection);

    if (hasSelection)
    {
        int row = ui->networksTable->currentRow();
        QString name = ui->networksTable->item(row, 0)->text();
        QString signal = ui->networksTable->item(row, 1)->text();
        QString security = ui->networksTable->item(row, 2)->text();

        ui->selectedNetworkInfo->setText(
            QString("Selected: %1 (%2, %3)").arg(name).arg(signal).arg(security));
    }
    else
    {
        ui->selectedNetworkInfo->setText("No network selected");
    }
}

void MainWindow::on_enableAdapterButton_clicked()
{
    ui->adapterStatusValue->setText("Enabled");
    ui->adapterStatusValue->setStyleSheet("color: #27ae60; font-weight: bold;");
    ui->enableAdapterButton->setEnabled(false);
    ui->disableAdapterButton->setEnabled(true);
}

void MainWindow::on_disableAdapterButton_clicked()
{
    ui->adapterStatusValue->setText("Disabled");
    ui->adapterStatusValue->setStyleSheet("color: #e74c3c; font-weight: bold;");
    ui->enableAdapterButton->setEnabled(true);
    ui->disableAdapterButton->setEnabled(false);
}

void MainWindow::on_refreshAdaptersButton_clicked()
{
    // Simulate refreshing adapter list
    ui->adaptersLabel->setText("Adapter list refreshed successfully!");
}

void MainWindow::on_adaptersList_itemSelectionChanged()
{
    QList<QListWidgetItem *> selectedItems = ui->adaptersList->selectedItems();
    bool hasSelection = !selectedItems.isEmpty();

    if (hasSelection)
    {
        QString adapterName = selectedItems.first()->text();
        // Remove emoji prefix for display
        if (adapterName.startsWith("üì° "))
            adapterName = adapterName.mid(2);
        else if (adapterName.startsWith("üîµ "))
            adapterName = adapterName.mid(2);
        else if (adapterName.startsWith("üîå "))
            adapterName = adapterName.mid(2);
        else if (adapterName.startsWith("üåê "))
            adapterName = adapterName.mid(2);

        ui->adapterNameValue->setText(adapterName);

        // Enable/disable buttons based on current status
        bool isEnabled = (ui->adapterStatusValue->text() == "Enabled");
        ui->enableAdapterButton->setEnabled(!isEnabled);
        ui->disableAdapterButton->setEnabled(isEnabled);
    }
}

void MainWindow::on_runDiagnosticsButton_clicked()
{
    ui->diagnosticsOutput->setPlainText(
        "Running network diagnostics...\n\n"
        "‚úì WiFi adapter detected and enabled\n"
        "‚úì Driver status: Healthy\n"
        "‚úì Signal strength: Good\n"
        "‚úì Internet connectivity: Available\n"
        "‚úì DNS resolution: Working\n"
        "‚úì Gateway reachable: Yes\n\n"
        "Diagnostics completed - No issues found!");
}

void MainWindow::on_resetNetworkButton_clicked()
{
    ui->diagnosticsOutput->setPlainText(
        "Resetting network stack...\n\n"
        "‚Ä¢ Flushing DNS resolver cache... Done\n"
        "‚Ä¢ Renewing IP address... Done\n"
        "‚Ä¢ Resetting Winsock catalog... Done\n"
        "‚Ä¢ Restarting network services... Done\n\n"
        "Network stack reset completed successfully!");
}

void MainWindow::on_flushDnsButton_clicked()
{
    ui->diagnosticsOutput->setPlainText("DNS cache flushed successfully!");
}

void MainWindow::on_restartWifiServiceButton_clicked()
{
    ui->diagnosticsOutput->setPlainText("WiFi service restarted successfully!");
}

void MainWindow::on_renewIpButton_clicked()
{
    ui->diagnosticsOutput->setPlainText("IP address renewed successfully!");
}

void MainWindow::on_forgetNetworkButton_clicked()
{
    ui->diagnosticsOutput->setPlainText("Selected network forgotten successfully!");
}

void MainWindow::on_driverUpdateButton_clicked()
{
    ui->diagnosticsOutput->setPlainText("Checking for driver updates...\n\nYour WiFi drivers are up to date!");
}

// Options page slots
void MainWindow::on_pushButton_saveSettings_clicked()
{
    ui->label_optionsTitle->setText("Settings saved successfully!");
}

void MainWindow::on_pushButton_resetSettings_clicked()
{
    // Reset to default values
    ui->checkBox_startWithWindows->setChecked(true);
    ui->checkBox_autoUpdate->setChecked(true);
    ui->checkBox_notifications->setChecked(true);
    ui->comboBox_theme->setCurrentIndex(2);    // System Default
    ui->comboBox_language->setCurrentIndex(0); // English

    ui->label_optionsTitle->setText("Settings reset to defaults!");
}

void MainWindow::on_pushButton_checkUpdates_clicked()
{
    ui->label_optionsTitle->setText("Checking for updates... Your software is up to date!");
}

void MainWindow::on_pushButton_refreshHardware_clicked()
{
    // Simulate hardware information gathering
    QString hardwareInfo;
    hardwareInfo += "<span style='color:#000000;'>";
    hardwareInfo += "üñ•Ô∏è SYSTEM HARDWARE INFORMATION<br>";
    hardwareInfo += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê<br><br>";

    // CPU Information
    hardwareInfo += "üîπ PROCESSOR (CPU)<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "Intel Core i7-12700K<br>";
    hardwareInfo += "   Cores: 12 Physical, 20 Logical<br>";
    hardwareInfo += "   Clock Speed: 3.6 GHz<br><br>";

    // Motherboard Information
    hardwareInfo += "üîß MOTHERBOARD<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "ASUS ROG STRIX Z690-A GAMING WIFI<br>";
    hardwareInfo += "   Version: Rev 1.xx<br><br>";

    // GPU Information
    hardwareInfo += "üéÆ GRAPHICS CARD (GPU)<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "NVIDIA GeForce RTX 4070<br>";
    hardwareInfo += "   VRAM: 12.0 GB<br>";
    hardwareInfo += "   Driver: 546.17<br>";
    hardwareInfo += "   Temperature: 42¬∞C<br>";
    hardwareInfo += "   Utilization: 8%<br><br>";

    // RAM Information
    hardwareInfo += "üíæ MEMORY (RAM)<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "32.0 GB<br>";
    hardwareInfo += "   Manufacturer: Corsair<br>";
    hardwareInfo += "   Speed: 3200 MHz<br><br>";

    // Storage Information
    hardwareInfo += "üíø STORAGE DRIVES<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "   ‚Ä¢ Samsung SSD 980 PRO 1TB (1.0 TB) [SSD]<br>";
    hardwareInfo += "   ‚Ä¢ Seagate Barracuda ST2000DM008 (2.0 TB) [HDD]<br><br>";

    // Network Information
    hardwareInfo += "üåê NETWORK ADAPTERS<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "   ‚Ä¢ Intel(R) Wi-Fi 6 AX201 160MHz (Ethernet 802.3)<br>";
    hardwareInfo += "      MAC: AA:BB:CC:DD:EE:FF<br>";
    hardwareInfo += "   ‚Ä¢ Realtek PCIe GbE Family Controller (Ethernet 802.3)<br>";
    hardwareInfo += "      MAC: 11:22:33:44:55:66<br><br>";

    // USB Information
    hardwareInfo += "üîå USB DEVICES<br>";
    hardwareInfo += "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ<br>";
    hardwareInfo += "8 connected USB devices<br><br>";

    hardwareInfo += "‚è±Ô∏è Last updated: " + QDateTime::currentDateTime().toString("hh:mm:ss AP");
    hardwareInfo += "</span>";

    ui->textEdit_hardwareInfo->setHtml(hardwareInfo);
    ui->label_hardwareStatus->setText("Hardware information updated successfully!");
}

void MainWindow::on_pushButton_exportHardware_clicked()
{
    ui->label_hardwareStatus->setText("Hardware report exported to hardware_info.txt");
}

// Update the on_hardwareButton_clicked() method:
void MainWindow::on_hardwareButton_clicked()
{
    setActiveButton(ui->hardwareButton);
    updateContent("Hardware Information");
    ui->contentStackedWidget->setCurrentWidget(ui->hardwarePage);

    // Auto-refresh hardware info when page is opened
    on_pushButton_refreshHardware_clicked();
}

void MainWindow::on_pushButton_refreshNetwork_clicked()
{
    // Simulate refreshing network status
    QStringList connectionTypes = {"WiFi", "Ethernet", "Mobile", "Disconnected"};
    QStringList statuses = {"Connected", "Connecting", "Disconnected", "Limited Access"};
    QStringList internetAccess = {"Available", "Unavailable", "Limited"};

    int randomType = rand() % connectionTypes.size();
    int randomStatus = rand() % statuses.size();
    int randomInternet = rand() % internetAccess.size();

    // Update connection status
    ui->label_connectionStatusValue->setText(statuses[randomStatus]);
    ui->label_connectionTypeValue->setText(connectionTypes[randomType]);
    ui->label_internetAccessValue->setText(internetAccess[randomInternet]);

    // Set color based on status
    if (statuses[randomStatus] == "Connected")
    {
        ui->label_connectionStatusValue->setStyleSheet("color: #27ae60; font-weight: bold;");
        ui->label_internetAccessValue->setStyleSheet("color: #27ae60; font-weight: bold;");
    }
    else if (statuses[randomStatus] == "Limited Access")
    {
        ui->label_connectionStatusValue->setStyleSheet("color: #e67e22; font-weight: bold;");
        ui->label_internetAccessValue->setStyleSheet("color: #e67e22; font-weight: bold;");
    }
    else
    {
        ui->label_connectionStatusValue->setStyleSheet("color: #e74c3c; font-weight: bold;");
        ui->label_internetAccessValue->setStyleSheet("color: #e74c3c; font-weight: bold;");
    }

    // Update IP addresses with random values
    QString ipv4 = QString("192.168.%1.%2").arg(rand() % 255).arg(rand() % 255);
    QString ipv6 = QString("2001:db8:%1:%2::%3").arg(rand() % 9999).arg(rand() % 9999).arg(rand() % 9999);
    QString gateway = QString("192.168.%1.1").arg(rand() % 255);

    ui->label_ipv4Value->setText(ipv4);
    ui->label_ipv6Value->setText(ipv6);
    ui->label_gatewayValue->setText(gateway);

    // Random DNS servers
    QStringList dnsServers = {"8.8.8.8, 8.8.4.4", "1.1.1.1, 1.0.0.1", "9.9.9.9, 149.112.112.112", "208.67.222.222, 208.67.220.220"};
    ui->label_dnsValue->setText(dnsServers[rand() % dnsServers.size()]);

    // Update SSID if connected via WiFi
    if (connectionTypes[randomType] == "WiFi")
    {
        QStringList ssids = {"HomeWiFi_5G", "Office_Network", "Guest_WiFi", "TP-Link_2.4G"};
        ui->label_ssidValue->setText(ssids[rand() % ssids.size()]);
    }
    else
    {
        ui->label_ssidValue->setText("N/A");
    }
}

void MainWindow::on_pushButton_testConnection_clicked()
{
    ui->textEdit_pingOutput->setPlainText("Testing internet connection...\n");

    // Simulate connection test with delay
    QTimer::singleShot(1000, this, [this]()
                       {
        ui->textEdit_pingOutput->append("‚úì DNS resolution: Working");
        QTimer::singleShot(500, this, [this]() {
            ui->textEdit_pingOutput->append("‚úì Gateway reachable: Yes");
            QTimer::singleShot(500, this, [this]() {
                ui->textEdit_pingOutput->append("‚úì Internet access: Available");
                QTimer::singleShot(500, this, [this]() {
                    ui->textEdit_pingOutput->append("‚úì Latency: 24ms");
                    ui->textEdit_pingOutput->append("\nConnection test completed successfully!");
                });
            });
        }); });
}

void MainWindow::simulatePing()
{
    m_pingCount++;
    if (m_pingCount > 10)
    {
        on_pushButton_stopPing_clicked();
        return;
    }

    int latency = 20 + (rand() % 30); // Random latency between 20-50ms
    int ttl = 64 - m_pingCount;

    QString pingResult = QString("Reply from %1: bytes=32 time=%2ms TTL=%3")
                             .arg(ui->lineEdit_pingTarget->text())
                             .arg(latency)
                             .arg(ttl);

    ui->textEdit_pingOutput->append(pingResult);
}

void MainWindow::on_pushButton_startPing_clicked()
{
    QString target = ui->lineEdit_pingTarget->text();
    if (target.isEmpty())
    {
        target = "google.com";
        ui->lineEdit_pingTarget->setText(target);
    }

    ui->textEdit_pingOutput->setPlainText(QString("Pinging %1...\n").arg(target));
    ui->pushButton_startPing->setEnabled(false);
    ui->pushButton_stopPing->setEnabled(true);

    // Simulate ping results
    m_pingTimer = new QTimer(this);
    m_pingCount = 0;
    connect(m_pingTimer, &QTimer::timeout, this, &MainWindow::simulatePing);
    m_pingTimer->start(1000);
}

void MainWindow::on_pushButton_stopPing_clicked()
{
    if (m_pingTimer && m_pingTimer->isActive())
    {
        m_pingTimer->stop();
        m_pingTimer->deleteLater();
        m_pingTimer = nullptr;
    }

    ui->textEdit_pingOutput->append("\nPing stopped by user.");
    ui->pushButton_startPing->setEnabled(true);
    ui->pushButton_stopPing->setEnabled(false);
}

void MainWindow::on_pushButton_stopTraceroute_clicked()
{
    if (m_tracerouteTimer && m_tracerouteTimer->isActive())
    {
        m_tracerouteTimer->stop();
        m_tracerouteTimer->deleteLater();
        m_tracerouteTimer = nullptr;
    }

    ui->textEdit_tracerouteOutput->append("\nTraceroute stopped by user.");
    ui->pushButton_startTraceroute->setEnabled(true);
    ui->pushButton_stopTraceroute->setEnabled(false);
}

void MainWindow::simulateTraceroute()
{
    m_tracerouteHop++;
    if (m_tracerouteHop > 15)
    {
        ui->textEdit_tracerouteOutput->append("\nTraceroute completed.");
        on_pushButton_stopTraceroute_clicked();
        return;
    }

    QStringList routers = {
        "192.168.1.1", "10.0.0.1", "172.16.0.1", "203.0.113.1",
        "198.51.100.1", "203.0.113.254", "192.0.2.1", "198.18.0.1",
        "192.88.99.1", "2001:db8::1", "2001:4860:4860::8888"};

    int latency1 = 1 + (rand() % 10);
    int latency2 = 1 + (rand() % 10);
    int latency3 = 1 + (rand() % 10);

    QString router = routers[rand() % routers.size()];
    QString tracerouteResult = QString("%1  %2 ms  %3 ms  %4 ms  %5")
                                   .arg(m_tracerouteHop, 2)
                                   .arg(latency1, 2)
                                   .arg(latency2, 2)
                                   .arg(latency3, 2)
                                   .arg(router);

    ui->textEdit_tracerouteOutput->append(tracerouteResult);

    // If we reached the final hop
    if (m_tracerouteHop == 15)
    {
        QString finalResult = QString("15  %1 ms  %2 ms  %3 ms  %4")
                                  .arg(24, 2)
                                  .arg(25, 2)
                                  .arg(23, 2)
                                  .arg(ui->lineEdit_tracerouteTarget->text());
        ui->textEdit_tracerouteOutput->append(finalResult);
    }
}
void MainWindow::on_pushButton_startTraceroute_clicked()
{
    QString target = ui->lineEdit_tracerouteTarget->text();
    if (target.isEmpty())
    {
        target = "google.com";
        ui->lineEdit_tracerouteTarget->setText(target);
    }

    ui->textEdit_tracerouteOutput->setPlainText(QString("Traceroute to %1...\n").arg(target));
    ui->pushButton_startTraceroute->setEnabled(false);
    ui->pushButton_stopTraceroute->setEnabled(true);

    // Simulate traceroute results
    m_tracerouteTimer = new QTimer(this);
    m_tracerouteHop = 0;
    connect(m_tracerouteTimer, &QTimer::timeout, this, &MainWindow::simulateTraceroute);
    m_tracerouteTimer->start(800);
}
void MainWindow::on_pushButton_startScan_clicked()
{
    QString target = ui->lineEdit_scannerTarget->text();
    if (target.isEmpty())
    {
        target = "localhost";
        ui->lineEdit_scannerTarget->setText(target);
    }

    int startPort = ui->spinBox_startPort->value();
    int endPort = ui->spinBox_endPort->value();

    if (startPort > endPort)
    {
        ui->label_scanSummary->setText("Error: Start port cannot be greater than end port");
        return;
    }

    ui->tableWidget_scanResults->setRowCount(0);
    ui->pushButton_startScan->setEnabled(false);
    ui->pushButton_stopScan->setEnabled(true);
    ui->progressBar_scan->setValue(0);

    // Simulate port scanning
    m_scanTimer = new QTimer(this);
    m_currentScanPort = startPort;
    m_scanEndPort = endPort;
    m_openPortsFound = 0;

    connect(m_scanTimer, &QTimer::timeout, this, &MainWindow::simulatePortScan);
    m_scanTimer->start(50); // Fast simulation
}

void MainWindow::on_pushButton_stopScan_clicked()
{
    if (m_scanTimer && m_scanTimer->isActive())
    {
        m_scanTimer->stop();
        m_scanTimer->deleteLater();
        m_scanTimer = nullptr;
    }

    ui->pushButton_startScan->setEnabled(true);
    ui->pushButton_stopScan->setEnabled(false);
    ui->progressBar_scan->setValue(100);

    ui->label_scanSummary->setText(
        QString("Scan stopped. %1 ports scanned, %2 open ports found")
            .arg(m_currentScanPort - ui->spinBox_startPort->value())
            .arg(m_openPortsFound));
}

void MainWindow::simulatePortScan()
{
    if (m_currentScanPort > m_scanEndPort)
    {
        on_pushButton_stopScan_clicked();
        ui->label_scanSummary->setText(
            QString("Scan completed. %1 ports scanned, %2 open ports found")
                .arg(m_scanEndPort - ui->spinBox_startPort->value() + 1)
                .arg(m_openPortsFound));
        return;
    }

    // Update progress
    int totalPorts = m_scanEndPort - ui->spinBox_startPort->value() + 1;
    int progress = ((m_currentScanPort - ui->spinBox_startPort->value()) * 100) / totalPorts;
    ui->progressBar_scan->setValue(progress);

    // Common open ports with their services
    QMap<int, QString> commonPorts = {
        {21, "FTP"}, {22, "SSH"}, {23, "Telnet"}, {25, "SMTP"}, {53, "DNS"}, {80, "HTTP"}, {110, "POP3"}, {143, "IMAP"}, {443, "HTTPS"}, {993, "IMAPS"}, {995, "POP3S"}, {1433, "MSSQL"}, {3306, "MySQL"}, {3389, "RDP"}, {5432, "PostgreSQL"}, {6379, "Redis"}, {27017, "MongoDB"}};

    // Simulate finding open ports (random chance + common ports)
    bool isOpen = false;
    QString service = "Unknown";

    if (commonPorts.contains(m_currentScanPort))
    {
        // Higher chance for common ports to be "open" in simulation
        isOpen = (rand() % 100) < 30; // 30% chance
        service = commonPorts[m_currentScanPort];
    }
    else
    {
        // Lower chance for other ports
        isOpen = (rand() % 100) < 5; // 5% chance
        service = "Unknown";
    }

    if (isOpen)
    {
        m_openPortsFound++;
        int row = ui->tableWidget_scanResults->rowCount();
        ui->tableWidget_scanResults->insertRow(row);

        ui->tableWidget_scanResults->setItem(row, 0, new QTableWidgetItem(QString::number(m_currentScanPort)));
        ui->tableWidget_scanResults->setItem(row, 1, new QTableWidgetItem(service));

        QTableWidgetItem *statusItem = new QTableWidgetItem("Open");
        statusItem->setForeground(QBrush(QColor("#27ae60")));
        ui->tableWidget_scanResults->setItem(row, 2, statusItem);
    }

    m_currentScanPort++;
}

// Network page slots
void MainWindow::on_networkButton_clicked()
{
    setActiveButton(ui->networkButton);
    updateContent("Network Tools");
    ui->contentStackedWidget->setCurrentWidget(ui->networkPage);

    // Auto-refresh network status when page is opened
    on_pushButton_refreshNetwork_clicked();
}#include "windowsutils.h"
#include <QDir>
#include <QFile>
#include <QFileInfo>
#include <QStandardPaths>
#include <QDebug>

WindowsUtils::WindowsUtils(QObject *parent) : QObject(parent)
{
    initializeCleanerItems();
}

void WindowsUtils::initializeCleanerItems()
{
    m_cleanerItems.clear();
    
    // SAFE locations only for Windows 10/11
    m_cleanerItems.append({
        "Temporary Files", 
        "Windows and user temporary files",
        getUserTempPath(),
        {"*.tmp", "*.temp", "*.log", "~*.*", "_*.*"},
        0,
        true,
        true
    });
    
    m_cleanerItems.append({
        "Windows Update Cache", 
        "Windows Update temporary files",
        getWindowsTempPath(),
        {"*.*"},
        0,
        true,
        true
    });
    
    m_cleanerItems.append({
        "System Log Files", 
        "System event and error logs",
        getWindowsLogsPath(),
        {"*.log", "*.etl", "*.evtx"},
        0,
        true,
        true
    });
    
    m_cleanerItems.append({
        "Memory Dump Files", 
        "System memory dump files",
        getMemoryDumpPath(),
        {"*.dmp", "*.hdmp"},
        0,
        true,
        true
    });
    
    m_cleanerItems.append({
        "Thumbnail Cache", 
        "Windows thumbnail cache",
        getThumbnailCachePath(),
        {"*.db", "thumbcache_*.db"},
        0,
        true,
        true
    });
    
    m_cleanerItems.append({
        "Prefetch Files", 
        "Windows prefetch files",
        getPrefetchPath(),
        {"*.pf"},
        0,
        true,
        true
    });
}

QVector<CleanerItem> WindowsUtils::scanJunkFiles()
{
    QVector<CleanerItem> result;
    
    for (int i = 0; i < m_cleanerItems.size(); ++i) {
        CleanerItem scannedItem = m_cleanerItems[i];
        
        // Calculate size for this location
        QDir dir(scannedItem.path);
        if (dir.exists()) {
            scannedItem.size = calculateDirectorySize(dir);
        } else {
            scannedItem.size = 0;
        }
        
        result.append(scannedItem);
    }
    
    return result;
}

qint64 WindowsUtils::cleanJunkFiles(const QVector<CleanerItem> &itemsToClean)
{
    qint64 totalFreed = 0;
    
    for (int i = 0; i < itemsToClean.size(); ++i) {
        const CleanerItem &item = itemsToClean[i];
        if (item.isSelected && item.isSafe) {
            qint64 beforeSize = calculateDirectorySize(QDir(item.path));
            deleteFilesByPattern(item.path, item.filePatterns);
            qint64 afterSize = calculateDirectorySize(QDir(item.path));
            totalFreed += (beforeSize - afterSize);
        }
    }
    
    return totalFreed;
}

qint64 WindowsUtils::calculateFolderSize(const QString &path)
{
    QDir dir(path);
    return calculateDirectorySize(dir);
}

qint64 WindowsUtils::calculateDirectorySize(const QDir &dir)
{
    qint64 size = 0;
    
    // Calculate file sizes
    QFileInfoList files = dir.entryInfoList(QDir::Files | QDir::Hidden | QDir::System | QDir::NoDotAndDotDot);
    for (const QFileInfo &file : files) {
        size += file.size();
    }
    
    // Calculate subdirectory sizes
    QFileInfoList dirs = dir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot);
    for (const QFileInfo &subDir : dirs) {
        size += calculateDirectorySize(QDir(subDir.absoluteFilePath()));
    }
    
    return size;
}

void WindowsUtils::deleteFilesByPattern(const QString &path, const QStringList &patterns)
{
    QDir dir(path);
    if (!dir.exists()) return;
    
    // Delete files matching patterns
    for (int i = 0; i < patterns.size(); ++i) {
        const QString &pattern = patterns[i];
        QFileInfoList files = dir.entryInfoList(QStringList() << pattern, 
                                               QDir::Files | QDir::Hidden | QDir::System);
        for (int j = 0; j < files.size(); ++j) {
            const QFileInfo &file = files[j];
            QFile::remove(file.absoluteFilePath());
        }
    }
    
    // Clean empty subdirectories (safe operation)
    QFileInfoList dirs = dir.entryInfoList(QDir::Dirs | QDir::NoDotAndDotDot);
    for (int i = 0; i < dirs.size(); ++i) {
        const QFileInfo &subDir = dirs[i];
        QString subDirPath = subDir.absoluteFilePath();
        QDir subDirObj(subDirPath);
        
        // Only delete if directory is empty
        if (subDirObj.entryList(QDir::AllEntries | QDir::NoDotAndDotDot).isEmpty()) {
            subDirObj.removeRecursively();
        }
    }
}

// Windows-specific path getters
QString WindowsUtils::getWindowsTempPath() const
{
    return QDir::cleanPath(QDir::tempPath() + "/.."); // Go to main Temp directory
}

QString WindowsUtils::getUserTempPath() const
{
    return QDir::tempPath();
}

QString WindowsUtils::getPrefetchPath() const
{
    return "C:/Windows/Prefetch";
}

QString WindowsUtils::getThumbnailCachePath() const
{
    QString localAppData = QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation);
    return QDir::cleanPath(localAppData + "/../Local/Microsoft/Windows/Explorer");
}

QString WindowsUtils::getWindowsLogsPath() const
{
    return "C:/Windows/Logs";
}

QString WindowsUtils::getMemoryDumpPath() const
{
    return "C:/Windows";
}#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include <QMainWindow>
#include <QPushButton>
#include <QTableWidget>
#include <QListWidget>
#include <QTextEdit>
#include <QProgressBar>
#include <QTimer>
#include <QMessageBox>
#include <QDateTime>
#include <QVector>

// Forward declaration to avoid including windowsutils.h in header
class WindowsUtils;

QT_BEGIN_NAMESPACE
namespace Ui {
class MainWindow;
}
QT_END_NAMESPACE

// Simple struct definition in header
struct CleanerItem {
    QString name;
    QString description;
    QString path;
    QStringList filePatterns;
    qint64 size;
    bool isSafe;
    bool isSelected;
};

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    // Navigation slots
    void on_generalButton_clicked();
    void on_wifiButton_clicked();
    void on_appsButton_clicked();
    void on_cleanerButton_clicked();
    void on_networkButton_clicked();
    void on_hardwareButton_clicked();
    void on_optionsButton_clicked();

    // Cleaner tab slots
    void on_scanQuickButton_clicked();
    void on_cleanQuickButton_clicked();
    void on_scanSystemButton_clicked();
    void on_cleanSystemButton_clicked();
    void on_selectAllSystemButton_clicked();
    void on_scanBrowsersButton_clicked();
    void on_cleanBrowsersButton_clicked();

    // Software Uninstaller slots
    void on_refreshSoftwareButton_clicked();
    void on_searchSoftwareInput_textChanged(const QString &searchText);
    void on_softwareTable_itemSelectionChanged();
    void on_uninstallSoftwareButton_clicked();
    void on_forceUninstallButton_clicked();

    // Apps page slots
    void on_addAppButton_clicked();
    void on_refreshAppsButton_clicked();
    void on_launchAppButton_clicked();
    void on_removeAppButton_clicked();
    void on_searchAppsInput_textChanged(const QString &searchText);

    // General tab slots
    void on_refreshSystemInfoButton_clicked();
    void on_generateReportButton_clicked();
    void on_disableStartupButton_clicked();
    void on_enableStartupButton_clicked();
    void on_startupTable_itemSelectionChanged();

    // WiFi Management slots
    void on_scanNetworksButton_clicked();
    void on_refreshNetworksButton_clicked();
    void on_connectNetworkButton_clicked();
    void on_disconnectNetworkButton_clicked();
    void on_networksTable_itemSelectionChanged();
    void on_enableAdapterButton_clicked();
    void on_disableAdapterButton_clicked();
    void on_refreshAdaptersButton_clicked();
    void on_adaptersList_itemSelectionChanged();
    void on_runDiagnosticsButton_clicked();
    void on_resetNetworkButton_clicked();
    void on_flushDnsButton_clicked();
    void on_restartWifiServiceButton_clicked();
    void on_renewIpButton_clicked();
    void on_forgetNetworkButton_clicked();
    void on_driverUpdateButton_clicked();

    // Options page slots
    void on_pushButton_saveSettings_clicked();
    void on_pushButton_resetSettings_clicked();
    void on_pushButton_checkUpdates_clicked();
    void on_pushButton_refreshHardware_clicked();
    void on_pushButton_exportHardware_clicked();

    // Network page slots
    void on_pushButton_refreshNetwork_clicked();
    void on_pushButton_testConnection_clicked();
    void on_pushButton_startPing_clicked();
    void on_pushButton_stopPing_clicked();
    void on_pushButton_startTraceroute_clicked();
    void on_pushButton_stopTraceroute_clicked();
    void on_pushButton_startScan_clicked();
    void on_pushButton_stopScan_clicked();

private:
    Ui::MainWindow *ui;
    WindowsUtils *m_windowsUtils;
    QVector<CleanerItem> m_currentCleanerItems;
    QTimer *m_pingTimer;
    QTimer *m_tracerouteTimer;
    QTimer *m_scanTimer;
    int m_pingCount;
    int m_tracerouteHop;
    int m_currentScanPort;
    int m_scanEndPort;
    int m_openPortsFound;

    void setupConnections();
    void resetAllButtons();
    void setActiveButton(QPushButton *activeButton);
    void updateContent(const QString &title);
    void showCleanerPage();
    void populateSoftwareTable();
    void simulatePing();
    void simulateTraceroute();
    void simulatePortScan();
    
    // New methods for cleaner functionality
    void updateSystemCleanerList();
    QString formatFileSize(qint64 bytes);
};

#endif // MAINWINDOW_H#ifndef WINDOWSUTILS_H
#define WINDOWSUTILS_H

#include <QObject>
#include <QString>
#include <QVector>
#include <QStringList>
#include <QDir>

struct CleanerItem {
    QString name;
    QString description;
    QString path;
    QStringList filePatterns;
    qint64 size;
    bool isSafe;
    bool isSelected;
};

class WindowsUtils : public QObject
{
    Q_OBJECT

public:
    explicit WindowsUtils(QObject *parent = nullptr);
    
    // System Cleaner Methods
    QVector<CleanerItem> scanJunkFiles();
    qint64 cleanJunkFiles(const QVector<CleanerItem> &itemsToClean);
    qint64 calculateFolderSize(const QString &path);

private:
    void deleteFilesByPattern(const QString &path, const QStringList &patterns);
    qint64 calculateDirectorySize(const QDir &dir);
    void initializeCleanerItems();
    
    // Safe locations for Windows 10/11 cleaning
    QString getWindowsTempPath() const;
    QString getUserTempPath() const;
    QString getPrefetchPath() const;
    QString getThumbnailCachePath() const;
    QString getWindowsLogsPath() const;
    QString getMemoryDumpPath() const;
    
    QVector<CleanerItem> m_cleanerItems;
};

#endif // WINDOWSUTILS_H